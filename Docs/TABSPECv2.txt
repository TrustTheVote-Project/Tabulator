This is the preliminary specification for the TTV Tabulator Code.

# Authors # Jeff Cook and John Sebes

# Purpose # Tabulate the votes for a specific jurisdiction during an election.

# States # INITIAL, ACCUMULATE, DONE, WARN, ERROR

# State Transition Description #
INITIAL > ERROR if the Input ElectionDefinition is not correct
INITIAL > ACCUMULATE if the Input Election Definition is not correct
ACCUMULATE > ERROR if the Input CounterCount is not correct
ACCUMULATE > ACCUMULATE if the Input CounterCount is correct
ACCUMULATE > WARN if the Input CounterCount is "extra"
ACCUMULATE > WARN if the operator requests total but doneP is false
ACCUMULATE > DONE if the operator requests total but doneP is false

*JVC* In my thinking, if an ElectionDefinition is invalid, then it is not
 accepted and the state goes back to INITIAL. I cannot image a scenario under
 which an invalid ElectionDefinition is accepted, unless the tabulator
 operator is permitted to alter the specs on the fly (is this the case?). If a
 ContestCount is invalid, then it is not accepted, and we go back to
 ACCUMULATE.  Under what scenarios will we accept an invalid CounterCount?
 Also, I think there are potential WARNING indicators after each operation,
 but not necessarily a WARN state. Same for ERROR (unless we can accept
 invalid/incomplete data sets).  Please clarify.

- "correct: CounterCount means: all IDs defined in ElectionDefinition
- "extra" CounterCount means: correct, but not in the set of "expected_counts" defined in the ElectionDefinition
- doneP is a predicate that is true IFF for each "expected_counts" exactly one CounterCount input has been provided

# State Transition Diagram # Needs update

INITIAL (Input: Election Definition)
|--> ACCUMULATE (Input: Counter Count) <--|
|    |------------------------------------|
|----|--> ERROR

# Descriptions of Input Data Sets #

See BNF7.txt

# Consistency of Input Data Sets #

- "save" is short for "check that all required fields are present, ignore others, and save in a local data structure for fast future access and checking."
- "check unique id" is short for "check whether the object's id is unique among all object IDs in the ElectionDefinition"
- "check defined id" is short for "check whether referenced object id is defined in the ElectionDefinition"

Election Definition
1) <AuditTrail>   ignore
2) <Election>     save election_id & reporting_groups
3) <Jurisdiction> save jurisdiction_id
4) <District>+    save district_ids, check unique id
5) <Precinct>+    save precinct_ids, check unique id, check defined id for referenced districts and counters
                  *JVC* check for duplicate district ids within a precinct (ERROR or WARNING?)
6) <Counter>+     save counter_ids, check unique id
7) <Contest>+     save contest_ids, check unique id, check defined id for referenced district and candidates
                  *JVC* check for duplicate candidate ids within a contest (ERROR)
                  *JVC* check for duplicate answers within a contest (ERROR)
8) <Candidate>+   save candidate_ids, check unique id
9) All other objects     ignore

Counter Count
1) <AuditTrail>        save file_id, must be new
2) election_id:        must be saved election_id
3) jurisdiction_id:    must be saved jurisdiction_id
4) precinct_id:        must be in saved precinct_ids
5) reporting_group:    should be in saved reporting_groups
6) counter_id:         must be in saved counter_ids, should be in precinct_id->expected_counts
7) cast_ballot_count:  must be numeric
8) <ContestCount>+
  
Contest Count
1) contest_id:        must be in saved contest_ids
2) under_vote_count:  must be numeric
3) over_vote_count:   must be numeric
4) write_in_count:    must be numeric
5a) <CandidateCount>+ candidate_id's must match those in saved contest
5b) <ReferendumCount> answers must match those in saved contest
6) cast_ballot_count should reconcile with counts
6a) For vote-for-one contests, cast_ballot_count =? sum of candidate counts, plus each of under_vote_count, over_vote_count, write_in_count

*JVC* See the file ERRORS.txt for a list of the errors and warnings currently
 generated by the Tabulator.

# Operations on Input Data Sets #

Election Description
1) Check consistency and completeness of ElectionDefinition.
2) Construct proto-tabulator count, incorporate ElectionDefinition.
3) Save to persistent storage.

*JVC* My concept of "persistent storage" for the Tabulator is simply the YAML
 file holding the current Tabulator Count.  The existence of this file implies
 we are past the INITIAL state.  Each Tabulator invocation (except for RESET)
 begins with reading this file and re-checking the consistency of the
 ElectionDefinition, which rebuilds the data structures needed to check the
 validity of the next CounterCount and to update the Tabulator Count.

Counter Count(s)
1) Read current tabulator count from persistent storage.
2) Check consistency of counter count.
3) Incorporate vote counts into new tabulator count, updating audit trail. 
4) Save to persistent storage.

# Other Tabulator Operations #

1) For consistent/complete ElectionDefinition, gain operator confirmation for all of (not each of) Election, Jurisdiction, reporting groups, number of  districts, number of precincts, number of counters, number expected_counts, number of office contests, number of candidates, number of referenda
*JVC* You want me to display these items one at a time and ask if they are correct?
2) Prompt operator for media for input data set(s)
3) Read and perform operations of each input data set on the input media
4) Display m-out-of-n expected_counts received, m-out-of-n precincts with all expected counts, display warning status, prompt for more media, or total
5) Upon receiving total command, if warning state, display warning status and prompt for confirm total or return to input
6) Compute output data sets, and prepare reports (reports specified separately)

# Tabulator Output data sets

Output is a compilation of all CounterCounts provided, together with a list of aggregated counts for all contest, in data format as specified separately.
Output also includes the same information in a spreadsheet format, where for each contest, there is a column for each "bin" (contest/candidate for each candidate, contest/write-in, contest/under, & contest/over), each row is a single counter-count (with identifying info in leading columns), and there is a total row for each bin.

# Description of warning types
TBD
